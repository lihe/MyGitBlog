# [从 Function Calling 到 MCP：大模型如何真正接入真实世界？](https://github.com/lihe/MyGitBlog/issues/2)





> 当我们谈论 AI Agent、Copilot、企业级智能系统时，真正的分水岭早已不在模型参数量，而在一个更底层的问题上：

> 

> **大模型，究竟是“会说话的百科全书”，还是“能动手做事的系统”？**



Function Calling 和 MCP（Model Context Protocol），正是围绕这个问题展开的两代关键答案。



------





## **一、没有工具的大模型，本质上是“被困在房间里的人”**





早期的大语言模型，即便知识极其丰富，本质上仍然是一个**封闭系统**：



- 无法访问实时数据
- 不能查询数据库
- 不能操作文件系统
- 不能调用外部 API





它只能基于**训练时学到的静态知识**进行回答。



这在“解释概念”“生成文本”时问题不大，但一旦进入真实应用场景，就会立刻失效：



- 查最新数据
- 进行精确计算
- 与业务系统交互
- 执行确定性任务





**模型需要“手”和“工具”。**



------





## **二、Function Calling：第一次让模型“会用工具”**







### **1. Function Calling 是什么？**





Function Calling 是 OpenAI 在 2023 年提出的一种能力扩展机制，其核心目标只有一个：



> **让模型在推理过程中，决定是否调用外部函数，并生成结构化参数。**



需要特别强调的是：



- 模型 **不执行函数**
- 模型 **只输出调用意图与参数**
- 真正的执行发生在宿主程序（Backend / Server）中





换句话说，模型负责“想”，系统负责“做”。



------





### **2. 典型工作流程**



```
用户输入
↓
LLM 推理
↓
生成 function_name + arguments（JSON）
↓
宿主系统执行函数
↓
结果返回给 LLM
↓
最终自然语言回答
```

示例（简化）：

```
{
  "name": "get_weather",
  "arguments": {
    "city": "北京",
    "date": "今天"
  }
}
```



------





### **3. 为什么说 Function Calling 是一次重要跃迁？**





因为它第一次让大模型具备了：



- 与真实系统交互的能力
- 执行确定性任务的可能性
- 构建 Agent 的基础动作接口





我们今天在 Coze、Dify 等低代码 Agent 平台中看到的各种“插件”，本质上都是 **Function Calling 的工程封装**。



------





## **三、Function Calling 的工程代价与瓶颈**





Function Calling 虽然重要，但它从一开始就**不是为大规模系统设计的标准**。





### **1. 模型强依赖**





- 模型必须 **原生支持 Function Calling**
- 甚至需要 **专门的 Function Call 微调**





例如在 ShareGPT 风格的数据集中，会出现专门的结构字段：

```
{
  "from": "function_call",
  "value": "工具参数"
}
```

这意味着：



> **不是所有模型天然就“会用工具”。**



------





### **2. 协议碎片化问题**





不同模型、不同厂商的 Function Calling：



- Schema 不统一
- 调用格式不同
- 错误处理方式各异





工程上，几乎不可避免地需要为每个模型维护一套适配层。



------





### **3. 能力边界清晰但狭窄**





Function Calling 更像是：



- 单次
- 无状态
- 函数级别





它非常适合：



- 查天气
- 查订单
- 简单计算





但一旦进入：



- 多工具协作
- 状态管理
- 复杂资源访问





就会迅速变得笨重。



------





## **四、MCP 出现的背景：Function Calling 不够用了**







### **1. MCP 是什么？**





**MCP（Model Context Protocol）** 是 Anthropic 提出的一种开放标准协议，其目标不是“再发明一种函数调用”，而是：



> **为大模型与外部世界之间，建立一个标准化、可控、可扩展的通信层。**



一句话定义：



> MCP 是模型接入工具、数据和能力的“通用协议层”。



------





### **2. MCP 要解决的核心问题**





Function Calling 无法优雅解决的问题包括：



- 工具数量爆炸
- 数据源类型复杂（DB / 文件 / API / Git）
- 不同语言、不同部署环境
- 权限与安全边界不清晰
- 状态与上下文难以管理





MCP 的目标非常明确：



> **把“外部能力”系统性地包装成模型可理解、可控制的上下文接口。**



------





## **五、MCP 的标准架构（关键）**





MCP 采用典型的 **Client–Server 架构**：

```
LLM（Client）
   ↕ MCP Protocol
MCP Server
   ├─ Tools
   ├─ Resources
   └─ Prompts
```



### **MCP Server 提供三类能力**







#### **1️⃣ Tools（可执行能力）**





- 标准化工具接口
- 明确输入 / 输出 schema
- 受控权限







#### **2️⃣ Resources（数据资源）**





- 文件系统
- 数据库
- API 结果
- Git 仓库
- 本地或远程状态





模型可以“读资源”，而不是每次都靠 prompt 注入。





#### **3️⃣ Prompts（上下文模板）**





- 系统级规范
- 业务约束
- 任务模板





------





## **六、Function Calling vs MCP：本质对比**



| **维度** | **Function Calling** | **MCP**                |
| -------- | -------------------- | ---------------------- |
| 抽象层级 | 函数级               | 系统级                 |
| 本质     | 模型生成调用参数     | 模型接入外部世界的协议 |
| 状态管理 | 无                   | 支持（Server 维护）    |
| 工具规模 | 少量                 | 大规模                 |
| 协议标准 | 私有实现             | 开放标准               |
| 扩展性   | 差                   | 极强                   |
| 适用场景 | Demo / 小工具        | Agent / 企业系统       |



------





## **七、一个非常直观的类比**





- **Function Calling**：

  像是你打电话让秘书临时帮你办一件事

- **MCP**：

  像是你被授予了一整套办公系统的受控访问权限





前者是“临时动作”，后者是“长期协作”。



------





## **八、工程选型建议（非常重要）**







### **什么时候用 Function Calling？**





- 工具数量少（<10）
- 功能简单
- 单体应用
- 快速验证





👉 **90% 的聊天机器人 Demo**



------





### **什么时候必须用 MCP？**





- 多工具、多数据源
- AI Agent / Copilot
- 企业级系统
- 本地文件 / 内网服务
- 强安全与可扩展要求





👉 **真正可落地的 Agent 系统**



------





## **九、总结一句话**





> Function Calling 解决的是“模型怎么调用一个函数”，

> MCP 解决的是“模型如何安全、可扩展地接入真实世界”。



在 Agent 体系中：



- Function Calling 更像是“动作接口”
- MCP 更接近“模型的操作系统层”



